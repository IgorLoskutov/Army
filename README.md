Базовые типы юнитов:
- Unit: Абстрактный воин специализирующийся на нанесении физического урона
- SpellCaster: Абстрактный воин специализирующийся на нанесении магического урона

Вполне логично, что все юниты, наносящие магический урон способны наносить и физический. Физический урон, который наносит SpellCaster должен быть небольшим, так же SpellCaster имеет меньшее, по сравнению с Unit, количество очков здоровья.

Юниты, наносящие физический урон:
- Soldier [Солдат] : юнит без всяких специальных возможностей
- Rogue [Разбойник] : разбойника невозможно контратаковать
- Berserker [Берсерк] : на берсеркера не действует магия
- Vampire [Вампир] : при атаке / контратаке потребляет часть жизненных сил противника
- Werewolf [Оборотень] : умеет превращаться в волка (в состоянии волка имеет более высокий показатель жизненных сил и атаки, но получает больший урон от магии)

Юниты, способные к магии:
- Wizard [Волшебник] : атакует боевыми заклинаниями (лечебные заклинания имеют только половину силы)
- Healer [Целитель] : владеет целебными заклинаниями (боевые заклинания имеют только половину силы)
- Priest [Священник] : владеет целебными заклинаниями (боевые заклинания имеют только половину силы), наносит x2 урон нежити (Vampire, Necromancer)
- Warlock [Чернокнижник] : призывает демонов (класс Demon немного расширяет класс Soldier)
- Necromancer [Некромант] : следит за всеми кого атаковал, в случае смерти атакованого юнита, получает часть его жизненных сил

Интерфейсы:
- Observer [наблюдатель] : пригодится для Necromancer
- Observable [наблюдаемое] : пригодится для всех остальных


- Вынести механику атаки в виде отдельных классов
- Вынести заклинания в виде отдельных классов
- Вынести состояния юнитов в виде отдельных классов

- Придумать внятную систему разделения боевых магов и целителей
- Придумать внятную систему маркировки нежити

- Разделить урон на физический и магический
- Реализовать волшебникам книгу заклинаний (std::map и enum вам в этом помогут)
- Структурировать исходный код

Дополнительные возможности:
- Вампир может сделать вампиром другого юнита (исключение Werewolf)
- Оборотень может сделать оборотнем другого юнита (исключение Vampire)

Важно:
- Не забывайте, что в C++ есть наследование
- Не забывайте, что в С++ есть множественное наследование
- Не забывайте, что в С++ есть перегрузка функций

P.S.: Господа, данная задача на творчество. Я не ставлю вам никаких ограничений. Не следует задавать вопросы типа "Какой урон юнит наносит при контратаке?" или "Сколько очков здоровья должен получать Некромант?". Эта задача на проработку ООП. Чем сложнее и интереснее вы придумаете, тем больше опыта заработаете.

Часть 2. Не обязательно для допуска.

Игровое поле.
Смастерить доску размером 8x8, 16х16, 24х24 или других размеров. Каждая клетка доски - это объект Location с координатами. На одной клетке может находиться только один юнит. Соответственно, каждый юнит может перемещаться на какое-то количество клеток вперед, назад, вверх или вниз.

Нововведения:
- У каждого юнита есть радиус атаки и дальность ходьбы.
- У каждого заклинания есть радиус действия.
- Mount [Ездовые животные] - обладатель ездового животного может передвигаться на увеличенное количество клеток.
- Archer [Лучник] - умеет наносить урон на расстоянии.
- Солдата можно сделать лучником.

Часть 3. Пишу так, чисто поржать. Все равно никто не сделает.

Визуализация:
- Нарисовать доску в консоли.
- Если в клетке находится юнит - визуально это обозначить. 
